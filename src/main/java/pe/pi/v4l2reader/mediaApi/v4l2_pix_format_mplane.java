// Generated by jextract

package pe.pi.v4l2reader.mediaApi;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct v4l2_pix_format_mplane {
 *     __u32 width;
 *     __u32 height;
 *     __u32 pixelformat;
 *     __u32 field;
 *     __u32 colorspace;
 *     struct v4l2_plane_pix_format plane_fmt[8];
 *     __u8 num_planes;
 *     __u8 flags;
 *     union {
 *         __u8 ycbcr_enc;
 *         __u8 hsv_enc;
 *     };
 *     __u8 quantization;
 *     __u8 xfer_func;
 *     __u8 reserved[7];
 * }
 * }
 */
public class v4l2_pix_format_mplane {

    v4l2_pix_format_mplane() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        mediaAPI.align(mediaAPI.C_INT, 1).withName("width"),
        mediaAPI.align(mediaAPI.C_INT, 1).withName("height"),
        mediaAPI.align(mediaAPI.C_INT, 1).withName("pixelformat"),
        mediaAPI.align(mediaAPI.C_INT, 1).withName("field"),
        mediaAPI.align(mediaAPI.C_INT, 1).withName("colorspace"),
        MemoryLayout.sequenceLayout(8, v4l2_plane_pix_format.layout()).withName("plane_fmt"),
        mediaAPI.C_CHAR.withName("num_planes"),
        mediaAPI.C_CHAR.withName("flags"),
        MemoryLayout.unionLayout(
            mediaAPI.C_CHAR.withName("ycbcr_enc"),
            mediaAPI.C_CHAR.withName("hsv_enc")
        ).withName("$anon$2337:3"),
        mediaAPI.C_CHAR.withName("quantization"),
        mediaAPI.C_CHAR.withName("xfer_func"),
        MemoryLayout.sequenceLayout(7, mediaAPI.C_CHAR).withName("reserved")
    ).withName("v4l2_pix_format_mplane");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt width$LAYOUT = (OfInt)$LAYOUT.select(groupElement("width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 width
     * }
     */
    public static final OfInt width$layout() {
        return width$LAYOUT;
    }

    private static final long width$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 width
     * }
     */
    public static final long width$offset() {
        return width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 width
     * }
     */
    public static int width(MemorySegment struct) {
        return struct.get(width$LAYOUT, width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 width
     * }
     */
    public static void width(MemorySegment struct, int fieldValue) {
        struct.set(width$LAYOUT, width$OFFSET, fieldValue);
    }

    private static final OfInt height$LAYOUT = (OfInt)$LAYOUT.select(groupElement("height"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 height
     * }
     */
    public static final OfInt height$layout() {
        return height$LAYOUT;
    }

    private static final long height$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 height
     * }
     */
    public static final long height$offset() {
        return height$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 height
     * }
     */
    public static int height(MemorySegment struct) {
        return struct.get(height$LAYOUT, height$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 height
     * }
     */
    public static void height(MemorySegment struct, int fieldValue) {
        struct.set(height$LAYOUT, height$OFFSET, fieldValue);
    }

    private static final OfInt pixelformat$LAYOUT = (OfInt)$LAYOUT.select(groupElement("pixelformat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 pixelformat
     * }
     */
    public static final OfInt pixelformat$layout() {
        return pixelformat$LAYOUT;
    }

    private static final long pixelformat$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 pixelformat
     * }
     */
    public static final long pixelformat$offset() {
        return pixelformat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 pixelformat
     * }
     */
    public static int pixelformat(MemorySegment struct) {
        return struct.get(pixelformat$LAYOUT, pixelformat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 pixelformat
     * }
     */
    public static void pixelformat(MemorySegment struct, int fieldValue) {
        struct.set(pixelformat$LAYOUT, pixelformat$OFFSET, fieldValue);
    }

    private static final OfInt field$LAYOUT = (OfInt)$LAYOUT.select(groupElement("field"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 field
     * }
     */
    public static final OfInt field$layout() {
        return field$LAYOUT;
    }

    private static final long field$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 field
     * }
     */
    public static final long field$offset() {
        return field$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 field
     * }
     */
    public static int field(MemorySegment struct) {
        return struct.get(field$LAYOUT, field$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 field
     * }
     */
    public static void field(MemorySegment struct, int fieldValue) {
        struct.set(field$LAYOUT, field$OFFSET, fieldValue);
    }

    private static final OfInt colorspace$LAYOUT = (OfInt)$LAYOUT.select(groupElement("colorspace"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 colorspace
     * }
     */
    public static final OfInt colorspace$layout() {
        return colorspace$LAYOUT;
    }

    private static final long colorspace$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 colorspace
     * }
     */
    public static final long colorspace$offset() {
        return colorspace$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 colorspace
     * }
     */
    public static int colorspace(MemorySegment struct) {
        return struct.get(colorspace$LAYOUT, colorspace$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 colorspace
     * }
     */
    public static void colorspace(MemorySegment struct, int fieldValue) {
        struct.set(colorspace$LAYOUT, colorspace$OFFSET, fieldValue);
    }

    private static final SequenceLayout plane_fmt$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("plane_fmt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static final SequenceLayout plane_fmt$layout() {
        return plane_fmt$LAYOUT;
    }

    private static final long plane_fmt$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static final long plane_fmt$offset() {
        return plane_fmt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static MemorySegment plane_fmt(MemorySegment struct) {
        return struct.asSlice(plane_fmt$OFFSET, plane_fmt$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static void plane_fmt(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, plane_fmt$OFFSET, plane_fmt$LAYOUT.byteSize());
    }

    private static long[] plane_fmt$DIMS = { 8 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static long[] plane_fmt$dimensions() {
        return plane_fmt$DIMS;
    }
    private static final MethodHandle plane_fmt$ELEM_HANDLE = plane_fmt$LAYOUT.sliceHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static MemorySegment plane_fmt(MemorySegment struct, long index0) {
        try {
            return (MemorySegment)plane_fmt$ELEM_HANDLE.invokeExact(struct, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * struct v4l2_plane_pix_format plane_fmt[8]
     * }
     */
    public static void plane_fmt(MemorySegment struct, long index0, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, plane_fmt(struct, index0), 0L, v4l2_plane_pix_format.layout().byteSize());
    }

    private static final OfByte num_planes$LAYOUT = (OfByte)$LAYOUT.select(groupElement("num_planes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 num_planes
     * }
     */
    public static final OfByte num_planes$layout() {
        return num_planes$LAYOUT;
    }

    private static final long num_planes$OFFSET = 180;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 num_planes
     * }
     */
    public static final long num_planes$offset() {
        return num_planes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 num_planes
     * }
     */
    public static byte num_planes(MemorySegment struct) {
        return struct.get(num_planes$LAYOUT, num_planes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 num_planes
     * }
     */
    public static void num_planes(MemorySegment struct, byte fieldValue) {
        struct.set(num_planes$LAYOUT, num_planes$OFFSET, fieldValue);
    }

    private static final OfByte flags$LAYOUT = (OfByte)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 flags
     * }
     */
    public static final OfByte flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 181;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 flags
     * }
     */
    public static byte flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 flags
     * }
     */
    public static void flags(MemorySegment struct, byte fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfByte ycbcr_enc$LAYOUT = (OfByte)$LAYOUT.select(groupElement("$anon$2337:3"), groupElement("ycbcr_enc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 ycbcr_enc
     * }
     */
    public static final OfByte ycbcr_enc$layout() {
        return ycbcr_enc$LAYOUT;
    }

    private static final long ycbcr_enc$OFFSET = 182;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 ycbcr_enc
     * }
     */
    public static final long ycbcr_enc$offset() {
        return ycbcr_enc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 ycbcr_enc
     * }
     */
    public static byte ycbcr_enc(MemorySegment struct) {
        return struct.get(ycbcr_enc$LAYOUT, ycbcr_enc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 ycbcr_enc
     * }
     */
    public static void ycbcr_enc(MemorySegment struct, byte fieldValue) {
        struct.set(ycbcr_enc$LAYOUT, ycbcr_enc$OFFSET, fieldValue);
    }

    private static final OfByte hsv_enc$LAYOUT = (OfByte)$LAYOUT.select(groupElement("$anon$2337:3"), groupElement("hsv_enc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 hsv_enc
     * }
     */
    public static final OfByte hsv_enc$layout() {
        return hsv_enc$LAYOUT;
    }

    private static final long hsv_enc$OFFSET = 182;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 hsv_enc
     * }
     */
    public static final long hsv_enc$offset() {
        return hsv_enc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 hsv_enc
     * }
     */
    public static byte hsv_enc(MemorySegment struct) {
        return struct.get(hsv_enc$LAYOUT, hsv_enc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 hsv_enc
     * }
     */
    public static void hsv_enc(MemorySegment struct, byte fieldValue) {
        struct.set(hsv_enc$LAYOUT, hsv_enc$OFFSET, fieldValue);
    }

    private static final OfByte quantization$LAYOUT = (OfByte)$LAYOUT.select(groupElement("quantization"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 quantization
     * }
     */
    public static final OfByte quantization$layout() {
        return quantization$LAYOUT;
    }

    private static final long quantization$OFFSET = 183;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 quantization
     * }
     */
    public static final long quantization$offset() {
        return quantization$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 quantization
     * }
     */
    public static byte quantization(MemorySegment struct) {
        return struct.get(quantization$LAYOUT, quantization$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 quantization
     * }
     */
    public static void quantization(MemorySegment struct, byte fieldValue) {
        struct.set(quantization$LAYOUT, quantization$OFFSET, fieldValue);
    }

    private static final OfByte xfer_func$LAYOUT = (OfByte)$LAYOUT.select(groupElement("xfer_func"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 xfer_func
     * }
     */
    public static final OfByte xfer_func$layout() {
        return xfer_func$LAYOUT;
    }

    private static final long xfer_func$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 xfer_func
     * }
     */
    public static final long xfer_func$offset() {
        return xfer_func$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 xfer_func
     * }
     */
    public static byte xfer_func(MemorySegment struct) {
        return struct.get(xfer_func$LAYOUT, xfer_func$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 xfer_func
     * }
     */
    public static void xfer_func(MemorySegment struct, byte fieldValue) {
        struct.set(xfer_func$LAYOUT, xfer_func$OFFSET, fieldValue);
    }

    private static final SequenceLayout reserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("reserved"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static final SequenceLayout reserved$layout() {
        return reserved$LAYOUT;
    }

    private static final long reserved$OFFSET = 185;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static final long reserved$offset() {
        return reserved$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static MemorySegment reserved(MemorySegment struct) {
        return struct.asSlice(reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static void reserved(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, reserved$OFFSET, reserved$LAYOUT.byteSize());
    }

    private static long[] reserved$DIMS = { 7 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static long[] reserved$dimensions() {
        return reserved$DIMS;
    }
    private static final VarHandle reserved$ELEM_HANDLE = reserved$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static byte reserved(MemorySegment struct, long index0) {
        return (byte)reserved$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * __u8 reserved[7]
     * }
     */
    public static void reserved(MemorySegment struct, long index0, byte fieldValue) {
        reserved$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

