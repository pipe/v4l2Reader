// Generated by jextract

package pe.pi.v4l2reader.mediaApi;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct v4l2_format {
 *     __u32 type;
 *     union {
 *         struct v4l2_pix_format pix;
 *         struct v4l2_pix_format_mplane pix_mp;
 *         struct v4l2_window win;
 *         struct v4l2_vbi_format vbi;
 *         struct v4l2_sliced_vbi_format sliced;
 *         struct v4l2_sdr_format sdr;
 *         struct v4l2_meta_format meta;
 *         __u8 raw_data[200];
 *     } fmt;
 * }
 * }
 */
public class v4l2_format {

    v4l2_format() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        mediaAPI.C_INT.withName("type"),
        MemoryLayout.paddingLayout(4),
        v4l2_format.fmt.layout().withName("fmt")
    ).withName("v4l2_format");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __u32 type
     * }
     */
    public static final OfInt type$layout() {
        return type$LAYOUT;
    }

    private static final long type$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __u32 type
     * }
     */
    public static final long type$offset() {
        return type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __u32 type
     * }
     */
    public static int type(MemorySegment struct) {
        return struct.get(type$LAYOUT, type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __u32 type
     * }
     */
    public static void type(MemorySegment struct, int fieldValue) {
        struct.set(type$LAYOUT, type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union {
     *     struct v4l2_pix_format pix;
     *     struct v4l2_pix_format_mplane pix_mp;
     *     struct v4l2_window win;
     *     struct v4l2_vbi_format vbi;
     *     struct v4l2_sliced_vbi_format sliced;
     *     struct v4l2_sdr_format sdr;
     *     struct v4l2_meta_format meta;
     *     __u8 raw_data[200];
     * }
     * }
     */
    public static class fmt {

        fmt() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            v4l2_pix_format.layout().withName("pix"),
            v4l2_pix_format_mplane.layout().withName("pix_mp"),
            v4l2_window.layout().withName("win"),
            v4l2_vbi_format.layout().withName("vbi"),
            v4l2_sliced_vbi_format.layout().withName("sliced"),
            v4l2_sdr_format.layout().withName("sdr"),
            v4l2_meta_format.layout().withName("meta"),
            MemoryLayout.sequenceLayout(200, mediaAPI.C_CHAR).withName("raw_data")
        ).withName("$anon$2382:2");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout pix$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pix"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format pix
         * }
         */
        public static final GroupLayout pix$layout() {
            return pix$LAYOUT;
        }

        private static final long pix$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format pix
         * }
         */
        public static final long pix$offset() {
            return pix$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format pix
         * }
         */
        public static MemorySegment pix(MemorySegment union) {
            return union.asSlice(pix$OFFSET, pix$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format pix
         * }
         */
        public static void pix(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, pix$OFFSET, pix$LAYOUT.byteSize());
        }

        private static final GroupLayout pix_mp$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("pix_mp"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format_mplane pix_mp
         * }
         */
        public static final GroupLayout pix_mp$layout() {
            return pix_mp$LAYOUT;
        }

        private static final long pix_mp$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format_mplane pix_mp
         * }
         */
        public static final long pix_mp$offset() {
            return pix_mp$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format_mplane pix_mp
         * }
         */
        public static MemorySegment pix_mp(MemorySegment union) {
            return union.asSlice(pix_mp$OFFSET, pix_mp$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_pix_format_mplane pix_mp
         * }
         */
        public static void pix_mp(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, pix_mp$OFFSET, pix_mp$LAYOUT.byteSize());
        }

        private static final GroupLayout win$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("win"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_window win
         * }
         */
        public static final GroupLayout win$layout() {
            return win$LAYOUT;
        }

        private static final long win$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_window win
         * }
         */
        public static final long win$offset() {
            return win$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_window win
         * }
         */
        public static MemorySegment win(MemorySegment union) {
            return union.asSlice(win$OFFSET, win$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_window win
         * }
         */
        public static void win(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, win$OFFSET, win$LAYOUT.byteSize());
        }

        private static final GroupLayout vbi$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("vbi"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_vbi_format vbi
         * }
         */
        public static final GroupLayout vbi$layout() {
            return vbi$LAYOUT;
        }

        private static final long vbi$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_vbi_format vbi
         * }
         */
        public static final long vbi$offset() {
            return vbi$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_vbi_format vbi
         * }
         */
        public static MemorySegment vbi(MemorySegment union) {
            return union.asSlice(vbi$OFFSET, vbi$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_vbi_format vbi
         * }
         */
        public static void vbi(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, vbi$OFFSET, vbi$LAYOUT.byteSize());
        }

        private static final GroupLayout sliced$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("sliced"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_sliced_vbi_format sliced
         * }
         */
        public static final GroupLayout sliced$layout() {
            return sliced$LAYOUT;
        }

        private static final long sliced$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_sliced_vbi_format sliced
         * }
         */
        public static final long sliced$offset() {
            return sliced$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_sliced_vbi_format sliced
         * }
         */
        public static MemorySegment sliced(MemorySegment union) {
            return union.asSlice(sliced$OFFSET, sliced$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_sliced_vbi_format sliced
         * }
         */
        public static void sliced(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, sliced$OFFSET, sliced$LAYOUT.byteSize());
        }

        private static final GroupLayout sdr$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("sdr"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_sdr_format sdr
         * }
         */
        public static final GroupLayout sdr$layout() {
            return sdr$LAYOUT;
        }

        private static final long sdr$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_sdr_format sdr
         * }
         */
        public static final long sdr$offset() {
            return sdr$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_sdr_format sdr
         * }
         */
        public static MemorySegment sdr(MemorySegment union) {
            return union.asSlice(sdr$OFFSET, sdr$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_sdr_format sdr
         * }
         */
        public static void sdr(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, sdr$OFFSET, sdr$LAYOUT.byteSize());
        }

        private static final GroupLayout meta$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("meta"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * struct v4l2_meta_format meta
         * }
         */
        public static final GroupLayout meta$layout() {
            return meta$LAYOUT;
        }

        private static final long meta$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * struct v4l2_meta_format meta
         * }
         */
        public static final long meta$offset() {
            return meta$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * struct v4l2_meta_format meta
         * }
         */
        public static MemorySegment meta(MemorySegment union) {
            return union.asSlice(meta$OFFSET, meta$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * struct v4l2_meta_format meta
         * }
         */
        public static void meta(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, meta$OFFSET, meta$LAYOUT.byteSize());
        }

        private static final SequenceLayout raw_data$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("raw_data"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static final SequenceLayout raw_data$layout() {
            return raw_data$LAYOUT;
        }

        private static final long raw_data$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static final long raw_data$offset() {
            return raw_data$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static MemorySegment raw_data(MemorySegment union) {
            return union.asSlice(raw_data$OFFSET, raw_data$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static void raw_data(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, raw_data$OFFSET, raw_data$LAYOUT.byteSize());
        }

        private static long[] raw_data$DIMS = { 200 };

        /**
         * Dimensions for array field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static long[] raw_data$dimensions() {
            return raw_data$DIMS;
        }
        private static final VarHandle raw_data$ELEM_HANDLE = raw_data$LAYOUT.varHandle(sequenceElement());

        /**
         * Indexed getter for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static byte raw_data(MemorySegment union, long index0) {
            return (byte)raw_data$ELEM_HANDLE.get(union, 0L, index0);
        }

        /**
         * Indexed setter for field:
         * {@snippet lang=c :
         * __u8 raw_data[200]
         * }
         */
        public static void raw_data(MemorySegment union, long index0, byte fieldValue) {
            raw_data$ELEM_HANDLE.set(union, 0L, index0, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout fmt$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("fmt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     struct v4l2_pix_format pix;
     *     struct v4l2_pix_format_mplane pix_mp;
     *     struct v4l2_window win;
     *     struct v4l2_vbi_format vbi;
     *     struct v4l2_sliced_vbi_format sliced;
     *     struct v4l2_sdr_format sdr;
     *     struct v4l2_meta_format meta;
     *     __u8 raw_data[200];
     * } fmt
     * }
     */
    public static final GroupLayout fmt$layout() {
        return fmt$LAYOUT;
    }

    private static final long fmt$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     struct v4l2_pix_format pix;
     *     struct v4l2_pix_format_mplane pix_mp;
     *     struct v4l2_window win;
     *     struct v4l2_vbi_format vbi;
     *     struct v4l2_sliced_vbi_format sliced;
     *     struct v4l2_sdr_format sdr;
     *     struct v4l2_meta_format meta;
     *     __u8 raw_data[200];
     * } fmt
     * }
     */
    public static final long fmt$offset() {
        return fmt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     struct v4l2_pix_format pix;
     *     struct v4l2_pix_format_mplane pix_mp;
     *     struct v4l2_window win;
     *     struct v4l2_vbi_format vbi;
     *     struct v4l2_sliced_vbi_format sliced;
     *     struct v4l2_sdr_format sdr;
     *     struct v4l2_meta_format meta;
     *     __u8 raw_data[200];
     * } fmt
     * }
     */
    public static MemorySegment fmt(MemorySegment struct) {
        return struct.asSlice(fmt$OFFSET, fmt$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     struct v4l2_pix_format pix;
     *     struct v4l2_pix_format_mplane pix_mp;
     *     struct v4l2_window win;
     *     struct v4l2_vbi_format vbi;
     *     struct v4l2_sliced_vbi_format sliced;
     *     struct v4l2_sdr_format sdr;
     *     struct v4l2_meta_format meta;
     *     __u8 raw_data[200];
     * } fmt
     * }
     */
    public static void fmt(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, fmt$OFFSET, fmt$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

